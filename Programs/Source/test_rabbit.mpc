# ./compile.py -p 64 test_rabbit
# ./Scripts/rep-field.sh test_rabbit -P 18446744073709551557
# ./compile.py -R 64 test_rabbit
# ./Scripts/ring.sh test_rabbit


program.use_edabit(True)
program.set_rabbit(True)
from Compiler import util
from Compiler import floatingpoint

use_preOpL = True
use_preOpL2 = False

def RabbitBitDec(x, k):
    r_bits = [cint((x >> i) & 1) for i in range(k)]
    return r_bits

def RabbitLT(R, x, k):
    """
    res = R <? x (logarithmic rounds version)

    R: clear integer register
    x: array of secret bits
    """

    R_bits = RabbitBitDec(R, k)
    x_clear = [x[i].reveal() for i in range(k)]
    y = [program.curr_block.new_reg('s') for i in range(k)]
    z = [program.curr_block.new_reg('s') for i in range(k)]
    w = [program.curr_block.new_reg('s') for i in range(k)]
    one = program.curr_block.new_reg('s')
    one = 1

    for i in range(k):
        y[i] = x[i].bit_xor(R_bits[i]).bit_xor(1)

    z[k-1] = y[k-1]
    w[k-1] = y[k-1] ^ one

    y = y[::-1]
    if use_preOpL:
        z = floatingpoint.PreOpL(floatingpoint.mul_op, y)[::-1]
    elif use_preOpL2:
        z = floatingpoint.PreOpL2(floatingpoint.mul_op, y)[::-1]

    for i in range(k-1,0,-1): # no optimizing
        w[i-1] = z[i-1] ^ z[i]

    total = program.curr_block.new_reg('s')
    out = [program.curr_block.new_reg('s') for i in range(k)]
    total = one
    for i in range(k):
        out[i] = R_bits[i] & w[i];

    for i in range(k):
        total = total ^ out[i]

    return 1 - total

def customLTZ(s, a, k, kappa):
    """
    s = (a ?< 0)

    k: bit length of a
    """
    if program.use_rabbit():

        BIT_SIZE = 64
        M = None; R = None; r = None; r_bits = None; 
        length_eda = BIT_SIZE

        if (program.options.ring):
            # length_eda = program.bit_length + 1
            M = 2**(program.bit_length + 1)
            R = 2**(program.bit_length)
        else:
            # length_eda = 64
            M = program.P
            R = (M - 1) // 2
            # M = 2**64
            # R = 2**63
            # print(R)
            # print(M)
            # print(length_eda)

        r, r_bits = sint.get_edabit(length_eda, True)
#        r_clear = 6644667428801815279
#        print_ln('r_clear = %s', r_clear)
#        r = sint(r_clear)
#        r_bits = [sbit((r_clear >> i) & 1) for i in range(64)]

#        print_ln('a = %s, r = %s', a.reveal(), r.reveal())
        masked_a = (a + r).reveal()
#        print_ln('masked_a = %s', masked_a)
        masked_b = masked_a + M - R
#        print_ln('%s %s %s', masked_b, M, R)

        w1 = RabbitLT(masked_a, r_bits, BIT_SIZE)
        w2 = RabbitLT(masked_b, r_bits, BIT_SIZE)

#        print_ln('w1 = %s masked_a = %s r = %s', w1.reveal(), masked_a, r.reveal())
#        print_ln('w2 = %s masked_b = %s r = %s', w2.reveal(), masked_b, r.reveal())
        # Can this be fixed?
        w3 = (masked_b > 0)
#        print_ln('w3 = %s', w3.reveal())

        movs(s, sint.conv(w1 - w2 + w3))

def rabbit(a, b):
    res = sint()
    customLTZ(res, a-b, program.bit_length, None)
    return res


a = sint(0)
b = sint(5)
# print_ln('%s', program.P)
# print_ln('compare result: %s', rabbit(a,b).reveal())

#for i in range(-10, 10):
#    for j in range(-10, 10):
#        print_str('%s ', rabbit(sint(i), sint(j)).reveal())
#    print_ln('')




print_str('%s ', rabbit(sint(0), sint(1)).reveal() == 1)
#print_str('%s ', rabbit(sint(1), sint(0)).reveal() == 0)
#print_str('%s ', rabbit(sint(0), sint(-1)).reveal() == 0)
#print_str('%s ', rabbit(sint(-1), sint(0)).reveal() == 1)
#
#if (program.options.ring):
#	############################### Ring cases ###############################
#    print_str('%s ', rabbit(sint(18446744073709551615), sint(0)).reveal() == 1)
#    print_str('%s ', rabbit(sint(0), sint(18446744073709551615)).reveal() == 0)
#    # 2**63 is considered to be positive
#    print_str('%s ', rabbit(sint(9223372036854775808), sint(0)).reveal() == 0)
#    # 2**63-1 is positive
#    print_str('%s ', rabbit(sint(9223372036854775807), sint(0)).reveal() == 0)
#    print_str('%s ', rabbit(sint(0), sint(9223372036854775807)).reveal() == 1)
#    # 2**63+1 is negative
#    print_str('%s ', rabbit(sint(9223372036854775809), sint(0)).reveal() == 1)
#    print_str('%s ', rabbit(sint(0), sint(9223372036854775809)).reveal() == 0)
#else:
#	############################### Field cases ###############################
#    print_str('%s ', rabbit(sint(18446744073709551555), sint(0)).reveal() == 1)
#    print_str('%s ', rabbit(sint(1), sint(18446744073709551556)).reveal() == 0)
#    # (p-1)/2 is considered to be positive
#    print_str('%s ', rabbit(sint(9223372036854775778), sint(0)).reveal() == 0)
#    print_str('%s ', rabbit(sint(0), sint(9223372036854775778)).reveal() == 1)
#    # (p-1)/2-1 is positive
#    print_str('%s ', rabbit(sint(9223372036854775777), sint(0)).reveal() == 0)
#    print_str('%s ', rabbit(sint(0), sint(9223372036854775777)).reveal() == 1)
#    # (p-1)/2+1 is negative
#    print_str('%s ', rabbit(sint(9223372036854775779), sint(0)).reveal() == 1)
#    print_str('%s ', rabbit(sint(0), sint(9223372036854775779)).reveal() == 0)
#
#
#print_ln('')

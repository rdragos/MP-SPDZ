# ./Scripts/rep-field.sh test_rabbit -P 18446744073709551557
# ./compile.py -R 64 test_rabbit
# ./Scripts/ring.sh test_rabbit

# ./compile.py -p 64 bench_rabbit 2048 1 1024

program.use_edabit(True)
from Compiler import instructions_base

from Compiler import util
from Compiler import floatingpoint
from Compiler.config import P_VALUES
from math import log, ceil 


use_preOpL = False
use_preOpL2 = True

@vectorize
def RabbitLT(R, x, k):
    """
    res = R <? x (logarithmic rounds version)

    R: clear integer register
    x: array of secret bits
    """
    R_bits = cbits.bit_decompose_clear(R, 64)
    y = [sbit() for i in range(k)]
    z = [sbit() for i in range(k)]
    w = [sbit() for i in range(k)]

    for i in range(k):
        y[i] = x[i].bit_xor(R_bits[i])
        y[i] = ~y[i]

    z[k-1] = y[k-1]
    w[k-1] = ~y[k-1]

    y = y[::-1]

    def and_op(x, y, z=None):
        return x & y


    if use_preOpL:
        z = floatingpoint.PreOpL(and_op, y)[::-1]
    elif use_preOpL2:
        z = floatingpoint.PreOpL2(and_op, y)[::-1]

    for i in range(k-1,0,-1): # no optimizing
        w[i-1] = z[i-1] ^ z[i]

    out = [sbit() for i in range(k)]
    for i in range(k):
        out[i] = R_bits[i] & w[i]

    total = out[0]
    for i in range(1, k):
        total = total ^ out[i]

    return total


# from Compiler.comparison import *
@vectorize
def customLTZ(s, a, k, kappa):
    BIT_SIZE = 64
    M = None; R = None;
    length_eda = BIT_SIZE

    if (program.options.ring):
        M = 2**(program.bit_length + 1)
        R = 2**(program.bit_length)
    else:
        # length_eda = 64
        M = P_VALUES[64]
        R = (M - 1) // 2
    r, r_bits = sint.get_edabit(length_eda, True)
    masked_a = (a + r).reveal()
    masked_b = masked_a + M - R

    w = [None, None, None, None]

    w[1] = RabbitLT(masked_a, r_bits, BIT_SIZE)
    w[2] = RabbitLT(masked_b, r_bits, BIT_SIZE)

    w[3] = cint(masked_b > 0)
    w3_bits = cbits.bit_decompose_clear(w[3], 64)

    movs(s, sint.conv(w[1] ^ w[2] ^ w3_bits[0]))





def print_bits(bits):
    for i in range(len(bits)):
        print_str('%s', bits[i].reveal().to_regint_by_bit())

def print_register_bits(bits):
    for i in range(len(bits)):
        print_str('%s', bits[i].reveal() )



################################ Carry Babbit ################################

@vectorize
def carry_babbit(b, a, compute_p=True):
    """ Carry propogation:
        b = (p1, g1)
        b = (p2, g2)
        (p,g) = (p_2, g_2)o(p_1, g_1) -> (p_1 & p_2, g_2 | (p_2 & g_1))
    """
    t1 = a[0].bit_and(b[0])
    t2 = a[1] + a[0].bit_and(b[1])
    return (t1, t2)


@vectorize
def CarryOutAuxBabbit(a, kappa):
    k = len(a)
    if k > 1 and k % 2 == 1:
        raise Exception
        a.append(None)
        k += 1
    u = [None]*(k//2)
    a = a[::-1]
    if k > 1:
        for i in range(k//2):
            u[i] = carry_babbit(a[2*i], a[2*i+1], True)
        return CarryOutAuxBabbit(u[:k//2][::-1], kappa)
    else:
        return a[0][1]


@vectorize
def CarryOutRawBabbit(a, b, c=0):
    assert len(a) == len(b)
    k = len(a)
    d = [program.curr_block.new_reg('s') for i in range(k)]
    s = [program.curr_block.new_reg('s') for i in range(3)]
    for i in range(k):
        d[i] = list(b[i].half_adder(a[i]))

    return CarryOutAuxBabbit(d[::-1], None)


# carry out with carry-in bit c
@vectorize
def CarryOutBabbit(res, a, b, d, c=0, kappa=None):
    """
    res = last carry bit in addition of a and b

    a: array of clear bits
    b: array of secret bits (same length as a)
    c: initial carry-in bit
    """
    k = len(a)
    movs(res, sint.conv((CarryOutRawBabbit(a, b, c) ^ d)))






@vectorize
def customLTZC(s, a, k, kappa):
    """
    s = (a ?< 2**(k-1))
    No condition such as the above required 

    k: bit length of a
    """
    BIT_SIZE = 64
    M = None; R = None; r = None; r_bits = None; 
    length_eda = BIT_SIZE

    r, r_bits = sint.get_edabit(length_eda, False)
    masked_a = (a + r).reveal()
    clear_a = a.reveal()

    #Check MSB and LSB
    masked_a += 1
    for i in range(BIT_SIZE):
        r_bits[i] = ~r_bits[i]
    masked_a_bits = cbits.bit_decompose_clear(masked_a, BIT_SIZE)

    d = [None] * BIT_SIZE
    for i in range(k):
        d[i] = list(r_bits[i].half_adder(masked_a_bits[i]))

    def cpo_op(b, a, z=None):
        t = [program.curr_block.new_reg('s') for i in range(2)]
        t[0] = a[0].bit_and(b[0])
        t[1] = a[0].bit_and(b[1]) + a[1]
        return t[0], t[1]

    d = r_bits[k-1] ^ masked_a_bits[k-1]
    masked_a_bits[k-1] = masked_a_bits[k-1].long_one()

    r_bits[k-1] = r_bits[k-1] ^ r_bits[k-1]
    CarryOutBabbit(s, masked_a_bits, r_bits, d)



@vectorize
def rabbit(a):
    res = sint()
    customLTZ(res, a, program.bit_length, None)
    return res

@vectorize
def rabbitLTC(a):
    res = sint()
    customLTZC(res, a, 64, None)
    return res

n_threads = 1

l = 1
n=2**20
try:
    n_threads = int(program.args[1])
except:
    pass

try:
    n = int(program.args[2])
except:
    pass

try:
    l = int(program.args[3])
except:
    pass

res = sint.Array(n)
print('%d comparison in %d threads and %d rounds' % (n, n_threads, l))

start_timer(2)
@multithread(n_threads, n)
def _(base, m):
    print("m = ", m)
    @for_range(l)
    def _(i):
        rabbitLTC(sint(1, size=m)).store_in_mem(base)

stop_timer(2)


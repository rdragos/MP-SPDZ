# ./Scripts/rep-field.sh test_rabbit -P 18446744073709551557
# ./compile.py -R 64 test_rabbit
# ./Scripts/ring.sh test_rabbit

# ./compile.py -p 64 bench_rabbit 2048 1 1024

program.use_edabit(True)
from Compiler import instructions_base

from Compiler import util
from Compiler import floatingpoint
from Compiler.config import P_VALUES
from math import log, ceil 


use_preOpL = False
use_preOpL2 = True

def print_bits(bits):
    for i in range(len(bits)):
        print_str('%s', bits[i].reveal().to_regint_by_bit())

def print_register_bits(bits):
    for i in range(len(bits)):
        print_str('%s', bits[i].reveal() )



################################ Carry Babbit ################################

@vectorize
def carry_babbit(b, a, compute_p):
    """ Carry propogation:
        b = (p1, g1)
        b = (p2, g2)
        (p,g) = (p_2, g_2)o(p_1, g_1) -> (p_1 & p_2, g_2 | (p_2 & g_1))
    """
#    t1 = a[0].bit_and(b[0])
#     t2 = a[1] + a[0].bit_and(b[1])
#     return (t1, t2)

    t = [program.curr_block.new_reg('s') for i in range(3)]
    if compute_p:
        t[0] = a[0].bit_and(b[0])
    t[2] = a[1] + b[1].bit_and(a[0])
    print(type(t[0]), type(t[2]))
    return t[0], t[2]



@vectorize
def CarryOutAuxBabbit(a, kappa):
    k = len(a)
    if k > 1 and k % 2 == 1:
        raise Exception
        a.append(a[0])
        k += 1
    u = [a[0]]*(k//2)
    a = a[::-1]
    if k > 1:
        for i in range(k//2):
            u[i] = carry_babbit(a[2*i], a[2*i+1], i != k//2-1)
        return CarryOutAuxBabbit(u[:k//2][::-1], kappa)
    else:
        return a[0][1]


@vectorize
def CarryOutRawBabbit(a, b, c=0):
    assert len(a) == len(b)
    k = len(a)
    d = [program.curr_block.new_reg('s') for i in range(k)]
    s = [program.curr_block.new_reg('s') for i in range(3)]
    for i in range(k):
        d[i] = list(b[i].half_adder(a[i]))
        print("d = ", type(d[i][0]), type(d[i][1]))

    return CarryOutAuxBabbit(d[::-1], None)


# carry out with carry-in bit c
@vectorize
def CarryOutBabbit(res, a, b, d, c=0, kappa=None):
    """
    res = last carry bit in addition of a and b

    a: array of clear bits
    b: array of secret bits (same length as a)
    c: initial carry-in bit
    """
    k = len(a)
    movs(res, sint.conv((CarryOutRawBabbit(a, b, c) ^ d)))


@vectorize
def customLTZC(s, a, k, kappa):
    """
    s = (a ?< 2**(k-1))
    No condition such as the above required 

    k: bit length of a
    """
    BIT_SIZE = 64
    M = None; R = None; r = None; r_bits = None; 
    length_eda = BIT_SIZE

    r, r_bits = sint.get_edabit(length_eda, False)
    masked_a = (a + r).reveal()
    clear_a = a.reveal()

    #Check MSB and LSB
    masked_a += 1
    for i in range(BIT_SIZE):
        r_bits[i] = ~r_bits[i]
    masked_a_bits = cbits.bit_decompose_clear(masked_a, BIT_SIZE)

    d = [None] * BIT_SIZE
    for i in range(k):
        d[i] = list(r_bits[i].half_adder(masked_a_bits[i]))

    def cpo_op(b, a, z=None):
        t = [program.curr_block.new_reg('s') for i in range(2)]
        t[0] = a[0].bit_and(b[0])
        t[1] = a[0].bit_and(b[1]) + a[1]
        return t[0], t[1]

    d = r_bits[k-1] ^ masked_a_bits[k-1]
    masked_a_bits[k-1] = masked_a_bits[k-1].long_one()

    r_bits[k-1] = r_bits[k-1] ^ r_bits[k-1]
    CarryOutBabbit(s, masked_a_bits, r_bits, d)



@vectorize
def rabbitLTC(a):
    res = sint()
    customLTZC(res, a, 64, None)
    return res

n_threads = 1

l = 1
n=2**20
try:
    n_threads = int(program.args[1])
except:
    pass

try:
    n = int(program.args[2])
except:
    pass

try:
    l = int(program.args[3])
except:
    pass

res = sint.Array(n)
print('%d comparison in %d threads and %d rounds' % (n, n_threads, l))

start_timer(2)
@multithread(n_threads, n)
def _(base, m):
    print("m = ", m)
    @for_range(l)
    def _(i):
        rabbitLTC(sint(1, size=m)).store_in_mem(base)

stop_timer(2)


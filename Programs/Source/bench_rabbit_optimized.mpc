# ./Scripts/rep-field.sh test_rabbit -P 18446744073709551557
# ./compile.py -R 64 test_rabbit
# ./Scripts/ring.sh test_rabbit

# ./compile.py -p 64 bench_rabbit 2048 1 1024

program.use_edabit(True)
from Compiler import instructions_base

from Compiler import util
from Compiler import floatingpoint
from Compiler.config import P_VALUES

use_preOpL = False
use_preOpL2 = True

@vectorize
def RabbitLT(R, x, k):
    """
    res = R <? x (logarithmic rounds version)

    R: clear integer register
    x: array of secret bits
    """
    R_bits = cbits.bit_decompose_clear(R, 64)
    y = [sbit() for i in range(k)]
    z = [sbit() for i in range(k)]
    w = [sbit() for i in range(k)]

    for i in range(k):
        y[i] = x[i].bit_xor(R_bits[i])
        y[i] = ~y[i]

    z[k-1] = y[k-1]
    w[k-1] = ~y[k-1]

    y = y[::-1]

    def and_op(x, y, z=None):
        return x & y

    if use_preOpL:
        z = floatingpoint.PreOpL(and_op, y)[::-1]
    elif use_preOpL2:
        z = floatingpoint.PreOpL2(and_op, y)[::-1]

    for i in range(k-1,0,-1): # no optimizing
        w[i-1] = z[i-1] ^ z[i]

    out = [sbit() for i in range(k)]
    for i in range(k):
        out[i] = R_bits[i] & w[i]

    total = out[0]
    for i in range(1, k):
        total = total ^ out[i]

    return total

@vectorize
def customLTZ(s, a, k, kappa):
    """
    s = (a ?< 0)

    k: bit length of a
    """

####################################################################################
####################################################################################
    # BIT_SIZE = 64
    # M = None; R = None;
    # length_eda = BIT_SIZE

    # if (program.options.ring):
    #     M = 2**(program.bit_length + 1)
    #     R = 2**(program.bit_length)
    # else:
    #     # length_eda = 64
    #     M = P_VALUES[64]
    #     R = (M - 1) // 2
    # r, r_bits = sint.get_edabit(length_eda, True)
    # masked_a = (a + r).reveal()
    # masked_b = masked_a + M - R

    # w = [None, None, None, None]

    # w[1] = RabbitLT(masked_a, r_bits, BIT_SIZE)
    # w[2] = RabbitLT(masked_b, r_bits, BIT_SIZE)

    # w[3] = cint(masked_b > 0)
    # w3_bits = cbits.bit_decompose_clear(w[3], 64)

    # movs(s, sint.conv(w[1] ^ w[2] ^ w3_bits[0]))

####################################################################################
####################################################################################
    BIT_SIZE = 64
    M = None; R = None; r = None; r_bits = None; 
    length_eda = BIT_SIZE

    if (program.options.ring):
        M = 2**(program.bit_length + 1)
        R = 2**(program.bit_length)
    else:
        M = program.P
        R = (M - 1) // 2

    r, r_bits = sint.get_edabit(length_eda, True)
    masked_a = (a + r).reveal()



    if (program.options.ring):
        #Check MSB and LSB
        masked_a += 1
        for i in range(k):
            r_bits[i] = ~r_bits[i]
        masked_a_bits = cbits.bit_decompose_clear(masked_a, 64)
        secret = r_bits[0].bit_adder(r_bits, masked_a_bits)
        movs(s, sint.conv(secret[-1]))

    else:
        masked_b = masked_a + M - R

        w = [None, None, None, None]

        w[1] = RabbitLT(masked_a, r_bits, BIT_SIZE)
        w[2] = RabbitLT(masked_b, r_bits, BIT_SIZE)

        w[3] = cint(masked_b > 0)
        w3_bits = cbits.bit_decompose_clear(w[3], 64)

        movs(s, sint.conv(w[1] ^ w[2] ^ w3_bits[0]))




@vectorize
def rabbit(a, b):
    res = sint()
    customLTZ(res, a-b, program.bit_length, None)
    return res


m=2
print_ln("%s", rabbit(sint(0, size=m), sint(1, size=m)).reveal())


# n_threads = 1

# l = 1
# n=2**20
# try:
#     n_threads = int(program.args[1])
# except:
#     pass

# try:
#     n = int(program.args[2])
# except:
#     pass

# try:
#     l = int(program.args[3])
# except:
#     pass

# res = sint.Array(n)
# print('%d comparison in %d threads and %d rounds' % (n, n_threads, l))

# start_timer(2)
# @multithread(n_threads, n)
# def _(base, m):
#     print("m = ", m)
#     @for_range(l)
#     def _(i):
#         rabbit(sint(1, size=m), sint(0, size=m)).store_in_mem(base)

# stop_timer(2)




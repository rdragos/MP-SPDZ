# ./Scripts/rep-field.sh test_rabbit -P 18446744073709551557
# ./compile.py -R 64 test_rabbit
# ./Scripts/ring.sh test_rabbit

# ./compile.py -p 64 bench_rabbit 2048 1 1024

program.use_edabit(True)
from Compiler import instructions_base

from Compiler import util
from Compiler import floatingpoint
from Compiler.config import P_VALUES

use_preOpL = False
use_preOpL2 = True

@vectorize
def RabbitLT(R, x, k):
    """
    res = R <? x (logarithmic rounds version)

    R: clear integer register
    x: array of secret bits
    """
    R_bits = cbits.bit_decompose_clear(R, 64)
    y = [sbit() for i in range(k)]
    z = [sbit() for i in range(k)]
    w = [sbit() for i in range(k)]

    for i in range(k):
        y[i] = x[i].bit_xor(R_bits[i])
        y[i] = ~y[i]

    z[k-1] = y[k-1]
    w[k-1] = ~y[k-1]

    y = y[::-1]

    def and_op(x, y, z=None):
        return x & y

    # print(type(y[0] & y[1]))
    # print(type(z[0]))

    if use_preOpL:
        z = floatingpoint.PreOpL(and_op, y)[::-1]
    elif use_preOpL2:
        z = floatingpoint.PreOpL2(and_op, y)[::-1]

    for i in range(k-1,0,-1): # no optimizing
        w[i-1] = z[i-1] ^ z[i]

    out = [sbit() for i in range(k)]
    for i in range(k):
        out[i] = R_bits[i] & w[i]

    total = out[0]
    for i in range(1, k):
        total = total ^ out[i]

    return total


# from Compiler.comparison import *
@vectorize
def customLTZ(s, a, k, kappa):
    BIT_SIZE = 64
    M = None; R = None;
    length_eda = BIT_SIZE

    if (program.options.ring):
        M = 2**(program.bit_length + 1)
        R = 2**(program.bit_length)
    else:
        # length_eda = 64
        M = P_VALUES[64]
        R = (M - 1) // 2
    r, r_bits = sint.get_edabit(length_eda, True)
    masked_a = (a + r).reveal()
    masked_b = masked_a + M - R

    w = [None, None, None, None]

    w[1] = RabbitLT(masked_a, r_bits, BIT_SIZE)
    w[2] = RabbitLT(masked_b, r_bits, BIT_SIZE)

    w[3] = cint(masked_b > 0)
    w3_bits = cbits.bit_decompose_clear(w[3], 64)

    movs(s, sint.conv(w[1] ^ w[2] ^ w3_bits[0]))





def print_bits(bits):
    k = len(bits)
    r_clear = [program.curr_block.new_reg('s') for i in range(k)]
    for i in range(k):
        r_clear[i] = bits[i].reveal()
    for i in range(k):
        r_clear[i].print_reg_plain()




def CarryOutRabbit(res, a, b):
    """
    res = last carry bit in addition of a and b

    a: array of clear bits
    b: array of secret bits (same length as a)
    c: initial carry-in bit
    """
    # from .types import sint
    k = len(a)
    movs(res, sint.conv(~(CarryOutRawRabbit(a, b) ^ a[k-1] ^ b[k-1])))

def CarryOutRawRabbit(a, b):
    assert len(a) == len(b)
    k = len(a)
    # from . import types
    d = [program.curr_block.new_reg('s') for i in range(k)]
    # s = [program.curr_block.new_reg('s') for i in range(3)]

    # w = [sbit() for i in range(k)]
    # for i in range(k):
    #     w[i] = b[i].half_adder(a[i])[0]
    # print_bits(w)
    # print_ln(' :d[0]')
    # for i in range(k):
    #     w[i] = b[i].half_adder(a[i])[1]
    # print_bits(w)
    # print_ln(' :d[1]')

    for i in range(k):
        d[i] = list(b[i].half_adder(a[i]))
    # s[0] = d[-1][0].bit_and(c)
    # s[1] = d[-1][1] + s[0]
    # d[-1][1] = s[1]
    # print(len(d))
    return CarryOutAuxRabbit(d)

from math import log, ceil    
def CarryOutAuxRabbit(a):

    def carry_basic(b, a):
        t = [program.curr_block.new_reg('s') for i in range(2)]
        t[0] = a[0].bit_and(b[0])
        t[1] = a[0].bit_and(b[1]) + a[1]
        return t[0], t[1]

    k = len(a)
    assert k == 2**(int(ceil(log(k,2))))
    u = [None]*(k//2)
    # a = a[::-1]
    if k > 1:
        for i in range(k//2):
            u[i] = carry_basic(a[2*i+1], a[2*i])

        # w = [sbit() for i in range(k//2)]
        # for i in range(k//2):
        #     w[i] = u[i][0]
        # print_bits(w)
        # print_ln(' :P')
        # for i in range(k//2):
        #     w[i] = u[i][1]
        # print_bits(w)
        # print_ln(' :G')

        return CarryOutAuxRabbit(u)
    else:
        # print(len(a[0]))
        return a[0][0]




@vectorize
def customLTZC(s, a, k, kappa):
    """
    s = (a ?< 2**(k-1))
    No condition such as the above required 

    k: bit length of a
    """

    BIT_SIZE = 64
    M = None; R = None; r = None; r_bits = None; 
    length_eda = BIT_SIZE

    if (program.options.ring):
        M = 2**(program.bit_length + 1)
        R = 2**(program.bit_length)
    else:
        raise Exception("Got a problem here")

    r, r_bits = sint.get_edabit(length_eda, True)
    masked_a = (a + r).reveal()
    clear_a = a.reveal()


    #Check MSB and LSB
    masked_a += 1
    # print_bits(r_bits)
    # print_ln(' :r')
    # clear_a_bits = cbits.bit_decompose_clear(clear_a, BIT_SIZE)
    # print(len(clear_a_bits))
    # for i in range(BIT_SIZE):
    #     clear_a_bits[i].print_reg_plain()
    # print_ln(" :x")
    # print_str("LSB ........................................................ MSB")
    # print_ln(' ')
    # print_ln(' ')

    # r_bits[0].reveal().print_reg("r")
    for i in range(BIT_SIZE):
        r_bits[i] = ~r_bits[i]
    masked_a_bits = cbits.bit_decompose_clear(masked_a, BIT_SIZE)
    # print(len(masked_a_bits))
    
    # for i in range(BIT_SIZE):
    #     masked_a_bits[i].print_reg_plain()
    # print_ln(" :a+1")
    # print_bits(r_bits)
    # print_ln(" :~r")


####################################################################################
#################################### Attempt 1 #####################################
####################################################################################

    # # a[i] --> masked_a_bits[i]
    # # b[i] --> r_bits[i]
    # d = [[sbit(), sbit()] for i in range(k)]
    # for i in range(k):
    #     # d[i] = masked_a_bits[i] ^ r_bits[i]
    #     if masked_a_bits[i] == 1:
    #         d[i] = [~r_bits[i], r_bits[i]]
    #     else:
    #         d[i] = [r_bits[i], sbit(0)]

    # def cpo_op(p2, g2, p1, g1, z=None):
    #     return p1 & p2, g2 | (p2 & g1)

    # c = [sbit() for i in range(k)]
    # if use_preOpL:
    #     c = floatingpoint.PreOpL(cpo_op, d)
    # elif use_preOpL2:
    #     c = floatingpoint.PreOpL2(cpo_op, d)

    # s_bits = [sbit() for i in range(k)]
    # if masked_a_bits[0] == 1:
    #     s_bits[0] = ~r_bits[0]
    # else:
    #     s_bits[0] = r_bits[0]

    # for i in range(1, k, 1):
    #     s_bits[i] = masked_a_bits[i] ^ r_bits[i] ^ c[i-1]

    # # Lines 141 to 147 can be replaced by a single call to line 147 with i=k-1

    # # secret = r_bits[0].bit_adder(r_bits, masked_a_bits)
    # # movs(s, sint.conv(secret[-1]))
    # movs(s, s_bits[-1])


####################################################################################
#################################### Attempt 2 #####################################
####################################################################################

    # smallP = [sbit() for i in range(k)]
    # smallG = [sbit() for i in range(k)]
    # for i in range(k):
    #     # d[i] = masked_a_bits[i] ^ r_bits[i]
    #     if masked_a_bits[i] == 1:
    #         smallP[i] = ~r_bits[i]
    #         smallG[i] = r_bits[i]
    #     else:
    #         smallP[i] = r_bits[i]
    #         smallG[i] = sbit(0)

    # def cpo_op_p(p2, g2, p1, g1, z=None):
    #     return p1 & p2

    # def cpo_op_g(p2, g2, p1, g1, z=None):
    #     return g2 | (p2 & g1)

    # bigP = [sbit() for i in range(k)]
    # bigG = [sbit() for i in range(k)]

    # bigP[0] = smallP[0]
    # bigG[0] = smallG[0]

    # for i in range(1,k,1):
    #     bigP[i] = cpo_op_p(smallP[i], smallG[i], bigP[i-1], bigG[i-1])
    #     bigG[i] = cpo_op_g(smallP[i], smallG[i], bigP[i-1], bigG[i-1])

    # if masked_a_bits[k-1] == 1:
    #     movs(s, sint.conv(~r_bits[k-1] ^ pg[k-2][1]))
    # else:
    #     movs(s, sint.conv(r_bits[k-1] ^ pg[k-2][1]))



####################################################################################
#################################### Attempt 3 #####################################
####################################################################################

    # d = [None] * k
    # for i in range(k):
    #     if masked_a_bits[i] == 1:
    #         d[i] = (~r_bits[i], r_bits[i])
    #     else:
    #         d[i] = (r_bits[i], sbit(0))    

    # def cpo_op(d2, d1, z=True):
    #     return (d2[0] & d1[0], d2[1] | (d2[0] & d1[1]))

    # pg = floatingpoint.PreOpL(cpo_op, d)

    # if masked_a_bits[k-1] == 1:
    #     movs(s, sint.conv(~r_bits[k-1] ^ pg[k-2][1]))
    # else:
    #     movs(s, sint.conv(r_bits[k-1] ^ pg[k-2][1]))



####################################################################################
#################################### Attempt 4 #####################################
####################################################################################

    # d = [None] * k
    # pg = [None] * k
    # for i in range(k):
    #     if masked_a_bits[i] == 1:
    #         d[i] = (~r_bits[i], r_bits[i])
    #         pg[i] = (~r_bits[i], r_bits[i])
    #     else:
    #         d[i] = (~r_bits[i], r_bits[i])
    #         pg[i] = (~r_bits[i], r_bits[i])
    #         # d[i] = (r_bits[i], sbit(0))    
    #         # pg[i] = (r_bits[i], sbit(0))

    # def cpo_op(d2, d1, z=None):
    #     # return (d1[0] & d1[1], None)
    #     # return (d2[0] & d1[0], d2[0] & d1[1])
    #     t = d2[0].bit_and(d1[1])
    #     # return (d2[0] & d1[0], d2[1].bit_or(d2[0].bit_and(d1[1])))
    #     return (d2[0] & d1[0], d2[1].bit_xor(t).bit_xor(d2[1].bit_and(t)))

    # pg = CarryOutAux(d[::-1], None)

    # # print(type(d[0][0]))
    # # print(type(d[0][1]))
    # # c = d[0][0] & d[0][1]
    # # c = cpo_op(d[0], d[0])

    # # pg = floatingpoint.PreOpL(cpo_op, d)

    # # for i in range(1,k,1):
    # #     pg[i] = cpo_op(d[i], pg[i-1])
    
    # if masked_a_bits[k-1] == 1:
    #     movs(s, sint.conv(~r_bits[k-1] ^ pg[k-2][1]))
    # else:
    #     movs(s, sint.conv(r_bits[k-1] ^ pg[k-2][1]))


####################################################################################
#################################### Attempt 5 #####################################
####################################################################################

    # use KOpL(op, a):

####################################################################################
#################################### Attempt 6 #####################################
####################################################################################

    CarryOutRabbit(s, masked_a_bits, r_bits)


@vectorize
def rabbit(a):
    res = sint()
    customLTZ(res, a, program.bit_length, None)
    return res

@vectorize
def rabbitLTC(a):
    res = sint()
    customLTZC(res, a, program.bit_length, None)
    return res


m=10
#for i in range(10):
#    print_str("%s", rabbitLTC(sint(i, size=m)).reveal())
#print_ln('')
#for i in range(10):
#    print_str("%s", rabbitLTC(sint(2**63 + i, size=m)).reveal())
#

values = [2 ** 63 + 1, 2**63 + 2, 0, 1, 2, 3]
# values = [-1]
for a in values:
#    print_ln('%s', a)
    # print_str("%s", rabbit(sint(a, size=m)).reveal())
    print_ln(' ')
    print_str("%s", rabbitLTC(sint(a, size=m)).reveal())
    print_ln(' ')
    # print_ln('\n')
    # print_str("\n\nRabbitLTZC answer: %s", rabbitLTC(sint(a, size=m)).reveal())
    # print_ln('\n')

# n_threads = 1

# l = 1
# n=2**20
# try:
#     n_threads = int(program.args[1])
# except:
#     pass

# try:
#     n = int(program.args[2])
# except:
#     pass

# try:
#     l = int(program.args[3])
# except:
#     pass

# res = sint.Array(n)
# print('%d comparison in %d threads and %d rounds' % (n, n_threads, l))

# start_timer(2)
# @multithread(n_threads, n)
# def _(base, m):
#     print("m = ", m)
#     @for_range(l)
#     def _(i):
#         rabbit(sint(1, size=m), sint(0, size=m)).store_in_mem(base)

# stop_timer(2)




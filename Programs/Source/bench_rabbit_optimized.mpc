# ./Scripts/rep-field.sh test_rabbit -P 18446744073709551557
# ./compile.py -R 64 test_rabbit
# ./Scripts/ring.sh test_rabbit

# ./compile.py -p 64 bench_rabbit 2048 1 1024

program.use_edabit(True)
from Compiler import instructions_base

from Compiler import util
from Compiler import floatingpoint
from Compiler.config import P_VALUES

use_preOpL = False
use_preOpL2 = True

@vectorize
def RabbitLT(R, x, k):
    """
    res = R <? x (logarithmic rounds version)

    R: clear integer register
    x: array of secret bits
    """
    R_bits = cbits.bit_decompose_clear(R, 64)
    y = [sbit() for i in range(k)]
    z = [sbit() for i in range(k)]
    w = [sbit() for i in range(k)]

    for i in range(k):
        y[i] = x[i].bit_xor(R_bits[i])
        y[i] = ~y[i]

    z[k-1] = y[k-1]
    w[k-1] = ~y[k-1]

    y = y[::-1]

    def and_op(x, y, z=None):
        return x & y

    # print(type(y[0] & y[1]))
    # print(type(z[0]))

    if use_preOpL:
        z = floatingpoint.PreOpL(and_op, y)[::-1]
    elif use_preOpL2:
        z = floatingpoint.PreOpL2(and_op, y)[::-1]

    for i in range(k-1,0,-1): # no optimizing
        w[i-1] = z[i-1] ^ z[i]

    out = [sbit() for i in range(k)]
    for i in range(k):
        out[i] = R_bits[i] & w[i]

    total = out[0]
    for i in range(1, k):
        total = total ^ out[i]

    return total


# from Compiler.comparison import *
@vectorize
def customLTZ(s, a, k, kappa):
    BIT_SIZE = 64
    M = None; R = None;
    length_eda = BIT_SIZE

    if (program.options.ring):
        M = 2**(program.bit_length + 1)
        R = 2**(program.bit_length)
    else:
        # length_eda = 64
        M = P_VALUES[64]
        R = (M - 1) // 2
    r, r_bits = sint.get_edabit(length_eda, True)
    masked_a = (a + r).reveal()
    masked_b = masked_a + M - R

    w = [None, None, None, None]

    w[1] = RabbitLT(masked_a, r_bits, BIT_SIZE)
    w[2] = RabbitLT(masked_b, r_bits, BIT_SIZE)

    w[3] = cint(masked_b > 0)
    w3_bits = cbits.bit_decompose_clear(w[3], 64)

    movs(s, sint.conv(w[1] ^ w[2] ^ w3_bits[0]))





def CarryOutRabbit(res, a, b):
    """
    res = last carry bit in addition of a and b

    a: array of clear bits
    b: array of secret bits (same length as a)
    c: initial carry-in bit
    """
    k = len(a)
    movs(res, sint.conv(~(CarryOutRawRabbit(a, b) ^ a[k-1] ^ b[k-1])))

def CarryOutRawRabbit(a, b):
    assert len(a) == len(b)
    k = len(a)
    d = [program.curr_block.new_reg('s') for i in range(k)]

    for i in range(k):
        d[i] = list(b[i].half_adder(a[i]))
    return CarryOutAuxRabbit(d)

from math import log, ceil    
def CarryOutAuxRabbit(a):

    def carry_basic(b, a):
        t = [program.curr_block.new_reg('s') for i in range(2)]
        t[0] = a[0].bit_and(b[0])
        t[1] = a[0].bit_and(b[1]) + a[1]
        return t[0], t[1]

    k = len(a)
    assert k == 2**(int(ceil(log(k,2))))
    u = [None]*(k//2)
    if k > 1:
        for i in range(k//2):
            u[i] = carry_basic(a[2*i+1], a[2*i])
        return CarryOutAuxRabbit(u)
    else:
        return a[0][0]




@vectorize
def customLTZC(s, a, k, kappa):
    """
    s = (a ?< 2**(k-1))
    No condition such as the above required 

    k: bit length of a
    """

    BIT_SIZE = 64
    M = None; R = None; r = None; r_bits = None; 
    length_eda = BIT_SIZE

    if (program.options.ring):
        M = 2**(program.bit_length + 1)
        R = 2**(program.bit_length)
    else:
        raise Exception("Got a problem here")

    r, r_bits = sint.get_edabit(length_eda, True)
    masked_a = (a + r).reveal()
    clear_a = a.reveal()

    masked_a += 1
    for i in range(BIT_SIZE):
        r_bits[i] = ~r_bits[i]
    masked_a_bits = cbits.bit_decompose_clear(masked_a, BIT_SIZE)
    CarryOutRabbit(s, masked_a_bits, r_bits)


@vectorize
def rabbit(a):
    res = sint()
    customLTZ(res, a, program.bit_length, None)
    return res

@vectorize
def rabbitLTC(a):
    res = sint()
    customLTZC(res, a, program.bit_length, None)
    return res


m=10
#for i in range(10):
#    print_str("%s", rabbitLTC(sint(i, size=m)).reveal())
#print_ln('')
#for i in range(10):
#    print_str("%s", rabbitLTC(sint(2**63 + i, size=m)).reveal())
#

values = [2 ** 63 + 1, 2**63 + 2, 0, 1, 2, 3]
# values = [-1]
for a in values:
#    print_ln('%s', a)
    # print_str("%s", rabbit(sint(a, size=m)).reveal())
    print_ln(' ')
    print_str("%s", rabbitLTC(sint(a, size=m)).reveal())
    print_ln(' ')
    # print_ln('\n')
    # print_str("\n\nRabbitLTZC answer: %s", rabbitLTC(sint(a, size=m)).reveal())
    # print_ln('\n')

# n_threads = 1

# l = 1
# n=2**20
# try:
#     n_threads = int(program.args[1])
# except:
#     pass

# try:
#     n = int(program.args[2])
# except:
#     pass

# try:
#     l = int(program.args[3])
# except:
#     pass

# res = sint.Array(n)
# print('%d comparison in %d threads and %d rounds' % (n, n_threads, l))

# start_timer(2)
# @multithread(n_threads, n)
# def _(base, m):
#     print("m = ", m)
#     @for_range(l)
#     def _(i):
#         rabbit(sint(1, size=m), sint(0, size=m)).store_in_mem(base)

# stop_timer(2)



